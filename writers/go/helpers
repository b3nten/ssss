package helpers

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
)

type Serializable interface {
	TypeID() uint16
	toBytes(*bytes.Buffer)
}

func MarshalBinary[K any, KT interface {
	*K
	Serializable
}](value KT) ([]byte, error) {
	buf := bytes.Buffer{}
	value.toBytes(&buf)
	return buf.Bytes(), nil
}

func Ptr[K any](v K) *K {
	return &v
}

var UnknownFieldError = errors.New("unknown field index")

const lenSize = 4
const idSize = 2

type deserializer[K any] func(data []byte, offset int) (value K, len int, err error)

type serializer[K any] func(value K, b *bytes.Buffer) int

func deserializeBool(data []byte, offset int) (bool, int, error) {
	slice := data[offset:]
	if len(slice) < 1 {
		return false, 0, fmt.Errorf("insufficient data for bool")
	}
	val := slice[0] != 0
	return val, 1, nil
}

func deserializeInt8(data []byte, offset int) (int8, int, error) {
	slice := data[offset:]
	if len(slice) < 1 {
		return 0, 0, fmt.Errorf("insufficient data for int8")
	}
	val := int8(slice[0])
	return val, 1, nil
}

func deserializeUint8(data []byte, offset int) (uint8, int, error) {
	slice := data[offset:]
	if len(slice) < 1 {
		return 0, 0, fmt.Errorf("insufficient data for uint8")
	}
	val := uint8(slice[0])
	return val, 1, nil
}

func deserializeInt16(data []byte, offset int) (int16, int, error) {
	slice := data[offset:]
	if len(slice) < 2 {
		return 0, 0, fmt.Errorf("insufficient data for int16")
	}
	val := int16(slice[0])<<8 | int16(slice[1])
	return val, 2, nil
}

func deserializeUint16(data []byte, offset int) (uint16, int, error) {
	slice := data[offset:]
	if len(slice) < 2 {
		return 0, 0, fmt.Errorf("insufficient data for uint16")
	}
	val := uint16(slice[0])<<8 | uint16(slice[1])
	return val, 2, nil
}

func deserializeInt32(data []byte, offset int) (int32, int, error) {
	slice := data[offset:]
	if len(slice) < 4 {
		return 0, 0, fmt.Errorf("insufficient data for int32")
	}
	val := int32(slice[0])<<24 | int32(slice[1])<<16 | int32(slice[2])<<8 | int32(slice[3])
	return val, 4, nil
}

func deserializeUint32(data []byte, offset int) (uint32, int, error) {
	slice := data[offset:]
	if len(slice) < 4 {
		return 0, 0, fmt.Errorf("insufficient data for uint32")
	}
	val := uint32(slice[0])<<24 | uint32(slice[1])<<16 | uint32(slice[2])<<8 | uint32(slice[3])
	return val, 4, nil
}

func deserializeString(data []byte, offset int) (string, int, error) {
	slice := data[offset:]
	if len(slice) < 4 {
		return "", 0, fmt.Errorf("insufficient data for string length")
	}
	strLen := int(binary.LittleEndian.Uint32(slice))
	if strLen == 0 {
		return "", 4, nil
	}
	if len(slice[4:]) < strLen {
		return "", 0, fmt.Errorf("insufficient data for string content")
	}
	val := string(slice[4 : 4+strLen])
	return val, 4 + strLen, nil
}

func newListDeserializer[K any](elemDeserializer deserializer[K]) deserializer[[]K] {
	return func(data []byte, offset int) (value []K, l int, err error) {
		slice := data[offset:]
		if len(slice) < 4 {
			return nil, 0, fmt.Errorf("insufficient data for list length")
		}
		listLen := int(binary.LittleEndian.Uint32(slice))
		i := 4
		value = make([]K, 0)
		for i < listLen+4 {
			elem, n, err := elemDeserializer(data, offset+i)
			if err != nil {
				return nil, 0, err
			}
			value = append(value, elem)
			i += n
		}
		return value, listLen + 4, nil
	}
}

func serializeBool(value bool, b *bytes.Buffer) int {
	var boolByte byte = 0
	if value {
		boolByte = 1
	}
	b.WriteByte(boolByte)
	return 1
}

func serializeInt8(value int8, b *bytes.Buffer) int {
	b.WriteByte(byte(value))
	return 1
}

func serializeUint8(value uint8, b *bytes.Buffer) int {
	b.WriteByte(byte(value))
	return 1
}

func serializeInt16(value int16, b *bytes.Buffer) int {
	binary.Write(b, binary.LittleEndian, value)
	return 2
}

func serializeUint16(value uint16, b *bytes.Buffer) int {
	binary.Write(b, binary.LittleEndian, value)
	return 2
}

func serializeInt32(value int32, b *bytes.Buffer) int {
	binary.Write(b, binary.LittleEndian, value)
	return 4
}

func serializeUint32(value uint32, b *bytes.Buffer) int {
	binary.Write(b, binary.LittleEndian, value)
	return 4
}

func serializeString(value string, b *bytes.Buffer) int {
	strLen := uint32(len(value))
	binary.Write(b, binary.LittleEndian, strLen)
	b.WriteString(value)
	return 4 + len(value)
}

func serializeStruct[K Serializable](value K, b *bytes.Buffer) int {
	startLen := len(b.Bytes())
	value.toBytes(b)
	return len(b.Bytes()) - startLen
}

func newListSerializer[K any](elemSerializer serializer[K]) serializer[[]K] {
	return func(value []K, b *bytes.Buffer) int {
		serializeUint32(0, b)
		i := len(b.Bytes())
		for _, item := range value {
			elemSerializer(item, b)
		}
		binary.LittleEndian.PutUint32(b.Bytes()[i-lenSize:], uint32(len(b.Bytes())-i))
		return len(b.Bytes()) - i + lenSize
	}
}

func parse(parser func(data []byte, fieldIndex uint16, offset int) (int, error), bytes []byte) (int, error) {
	if len(bytes) < idSize+lenSize {
		return 0, fmt.Errorf("data too short: need at least 6 bytes for id and length")
	}
	dataSize := binary.LittleEndian.Uint32(bytes[idSize:])
	totalSize := int(dataSize) + idSize + lenSize
	if len(bytes) < totalSize {
		return 0, fmt.Errorf("data too short: expected %d bytes, got %d", totalSize, len(bytes))
	}
	for i := idSize + lenSize; i < totalSize; {
		fieldIndex, err := getField(bytes[i:])
		if err != nil {
			return totalSize, err
		}
		i += 2
		next, err := parser(bytes, fieldIndex, i)
		if err != nil {
			if errors.Is(err, UnknownFieldError) {
				return totalSize, nil
			} else {
				return totalSize, err
			}
		}
		i += next
	}
	return totalSize, nil
}

func getField(b []byte) (uint16, error) {
	if len(b) < 2 {
		return 0, fmt.Errorf("insufficient data for field index")
	}
	return binary.LittleEndian.Uint16(b), nil
}
